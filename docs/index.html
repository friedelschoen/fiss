<!doctype html>
<html lang=en>

<head>
  <title>Friedel's Initialization and Service Supervision</title>
  <meta charset=utf-8 />
  <meta name=viewport content='width=device-width,initial-scale=1' />
  <link rel=stylesheet href=assets/style.css />
  <script type=text/javascript src=assets/toggle-dark.js></script>
</head>

<body>
<div id=wrapper>
<span class=header><a class=title id=top href=#top>fiss 0.3.3</a><span class=right><span id=toggle_dark onclick=toggle_dark()> turn the lights on </span> <a href=https://github.com/friedelschoen/fiss><img id=github alt=GitHub src=assets/github-mark.svg /></a></span></span>
================================================================================

Aloha! You somehow landed on the website of <b>fiss</b> (<u>Friedel's Initialization and Service Supervision</u>). <b>fiss</b> is a supervision suite for Unix and Unix-like systems with the power off system initialization. This project is based on <b>runit</b> and other <b>daemontools</b>-based utilities. 

<a class=title id=manuals href=#manuals>fiss' manuals</a>
--------------------------------------------------------------------------------

<div class=list>* <a href="chpst.8.html"><b>chpst(8)</b></a> - runs a program with a changed process state </div>
<div class=list>* <a href="finit.8.html"><b>finit(8)</b></a> - a UNIX process no 1 </div>
<div class=list>* <a href="fsvc.8.html"><b>fsvc(8)</b></a> - fiss' service controller </div>
<div class=list>* <a href="fsvs.8.html"><b>fsvs(8)</b></a> - fiss' service superviser </div>
<div class=list>* <a href="halt.8.html"><b>halt(8)</b></a> - halts the system </div>
<div class=list>* <a href="halt.8.html"><b>reboot(8)</b></a> - reboots the system </div>
<div class=list>* <a href="halt.8.html"><b>poweroff(8)</b></a> - stop the system </div>
<div class=list>* <a href="modules-load.8.html"><b>modules-load(8)</b></a> - configure kernel modules at boot </div>
<div class=list>* <a href="shutdown.8.html"><b>shutdown(8)</b></a> â€“ bring down the system </div>
<div class=list>* <a href="sigremap.8.html"><b>sigremap(8)</b></a> - catches signals and redirects mapped signal to executable </div>
<div class=list>* <a href="vlogger.1.html"><b>vlogger(1)</b></a> - log messages to syslog or an arbitrary executable </div>
<div class=list>* <a href="zzz.8.html"><b>zzz(8)</b></a> - suspend or hibernate your system </div>

<a class=title id=init href=#init>What does an init-system do?</a>
--------------------------------------------------------------------------------

After the kernel has loaded all the hardware stuff and setting up a working environment, it executes <u>/sbin/init</u> by default which mounts pseude-drives, the root-drive read-writable and more. This depends on your system, the package does include start and stop scripts and basic agetty services. 

After the initialization is done, services must be started. A service is a long- running process, which needs to be restarted if it suddenly terminates. FreeBSD and other BSD's as far as I know, are handling services pretty rudimentally with plain shell scripts and without supervision. The most Linux distributions are shipped with SystemD which is the opposite of FreeBSD's rc.d idea. SystemD is one massive and bulky project with a lot of (useless) features. I've used Void Linux which is shipped with <b>runit</b>, a <b>daemontools</b>-derivate with initialization. Unlike <b>SystemD</b>, <b>runit</b> is a fine in-between: minimal but feature-rich. Bit too minimal so I thought of making <b>fiss</b>! 

<a class=title id=why href=#why>Why fiss tho?</a>
--------------------------------------------------------------------------------

<b>fiss</b> is a lightweight and easy-to-use tool for initializing and supervising long-running services on Unix-like systems. It provides a simple and reliable way to start, stop, and monitor services. It supports automatic restarts, logging, and customizable startup options. It's no fork and uses the standard POSIX libc without other runtime dependencies. <b>fiss</b> support all the features to make services efficient running. It can be compatible with <b>runit</b> and <b>daemontools</b> utilities and is highly customizable at runtime to make <b>fiss</b> fit your needs. 

<a class=title id=compare href=#compare>fiss vs runit</a>
--------------------------------------------------------------------------------

<b>runit</b> is a good init-system and is lovely to use but there are some features which are just missing. 

<div class=list>* <b>fiss</b> has service-ordering (aka. dependencies), thus if <u>service-b</u> depends on <u>service-a</u>, you can configure it as a dependency and <b>fiss</b> will keep <u>service-a</u> running as long as <u>service-b</u> is running. </div>
<div class=list>* <b>fiss</b> has background-services, some services just won't let you run them in foreground. <b>runit</b> solves this problem with <b>pause</b>, a little program which just waits on an incoming signal. But this solution requires extra resources and a process-slot. It's bearly possible to hit the process-roof but for every process, the kernel needs to reserve memory and manage cpu-time. </div>
<div class=list>* <b>runit</b> has no built-in environment settings, it always runs services with a clear environment and you can modify it with chpst. That extends the process chain and cost more start-up time. <b>fiss</b> has build-in environment options for changing the user and group, the arguments, argv[0] or environment-variables. This project also includes a simplified and rewritten version of chpst, for compatibility use. </div>
<div class=list>* <b>runit</b>'s controller sv is really basic. It does not need to be very beautiful or feature-rich, but enabling services and enabling services once (one time after boot) is not possible. <b>runit</b>'s <u>down</u>-file method seems more like a hack. <b>fiss</b> supports enabling and once-enabling by default. If you like <b>sv</b>'s simplicity or its helpers like <b>vsv</b> or <b>rsv</b>, there is a compatibility-layer for <b>runit</b> or <b>daemontools</b> </div>
<div class=list>* finit and fsvc directly call the service executable. That means there is no process-chaining as <b>runit</b> does. If you are running <b>runit</b> as init (runit-init):
- kernel executes <b>runit-init</b>
- this executes <b>runit</b>
- <b>runit</b> forks and executes <u>/etc/runit/{1,2,3}</u>
- <u>/etc/runit/2</u> executes <b>runsvdir</b>
- <b>runsvdir</b> forks and executes <b>runsv</b>
- and finally <b>runsv</b> executes the underlying service executable </div>
<div class=list>* Every fork and execute causes an overhead. Also <b>runsvdir</b> is decentralized, thus no central control unit can be used and every <b>runsv</b> has its own control unit. </div>
<div class=list>* On the other hand this results in more security, if a executable failes due to a bug, the underlying executable will catch this (if implemented). Which implementation is better is up to yourself. </div>
<div class=list>* <b>fiss</b> and <b>runit</b> are entirely written in C, init has to be minimal and a garbage collector would only slow down the whole system. With C you have direct control of the operating system. </div>
<div class=list>* <b>fiss</b> is written from scratch using the libc implementaions, this results in a readable code thus easier for contributers to dive into the codebase. <b>runit</b> and <b>daemontools</b> are written using the djb-library which is an alternative general library. It's completely fine to use the library and maybe it is even faster than your libc-implementation (glibc, musl, freebsd-libc). </div>

<a class=title id=install href=#install>Installation</a>
--------------------------------------------------------------------------------

Now that you are really hyped to install <b>fiss</b>, you first have to compile it. 

To compile make sure you have installed the dependencies.
- C compiler like <b>gcc</b> or <b>clang</b> which supports the <u>gnu99</u>-standard
- POSIX-compliant shell like dash or bash
- GNU make
- <a href="https://github.com/sunaku/md2man">md2man</a> to make the manuals 

If running <b>fiss</b>, you require to have following dependencies installed:
- POSIX-compliant shell like dash or bash
- GNU <b>awk</b> 

Download the last release from GitHub or clone this project with git to build from HEAD. 

+------------------------------------------------------------------------------+
| git clone https://github.com/friedelschoen/fiss.git                          |
| cd fiss/                                                                     |
+------------------------------------------------------------------------------+

Then you have to compile the project with make. 

+------------------------------------------------------------------------------+
| make binary   # to compile the executables                                   |
| make manual   # to compile the manuals                                       |
+------------------------------------------------------------------------------+

Executables are now stored in ./bin, standard configuration-files are stored in ./etc, runtime-required files are in ./share and manuals in ./man. 

<a class=title id=voidlinux href=#voidlinux>Installation on Void Linux</a>
--------------------------------------------------------------------------------

If you don't have the source-tree yet, clone and bootstrap it with git. 

+------------------------------------------------------------------------------+
| git clone https://github.com/void-linux/void-packages.git                    |
| cd void-packages/                                                            |
| ./xbps-src binary-bootstrap                                                  |
+------------------------------------------------------------------------------+

<b>fiss</b> is not a official package yet, as it's too unstable to include, but you can add my void-packages as remote and compile. 

+------------------------------------------------------------------------------+
| git remote add fiss https://github.com/friedelschoen/void-packages.git       |
| git pull fiss fiss                                                           |
| ./xbps-src pkg fiss                                                          |
| xi fiss                                     # if xtools is installed         |
| sudo xbps-install -R hostdir/binpkgs fiss   # if xtools is not installed     |
+------------------------------------------------------------------------------+

<a class=title id=convert-runit href=#convert-runit>Convert runit services</a>
--------------------------------------------------------------------------------

The very most runit-service should work with fsvc but some not very efficient, thats why converting them is handy. Because runit (and fiss) only execute the <u>./run</u> script, these scripts <u>can</u> be pretty bulky. 



All services installed by <b>xbps</b>, thus available in <a href="https://github.com/void-linux/void-packages.git"><b>void-packages</b></a> follow some unwritten rules (unwritten as I haven't found them yet but services tent to follow some similarities). 

Services tent to follow this structure: 

+------------------------------------------------------------------------------+
| #!/bin/sh (1)                                                                |
|                                                                              |
| [ -r ./conf ] && . .conf (2)                                                 |
| exec chpst -u user:group service -p $PORT $OPTS (3)                          |
+------------------------------------------------------------------------------+

(1) The <u>./run</u>-file always is a shell-executable, which executes the actual service. 

(2) If <u>./conf</u> exist in the service-directory, it is sourced. 

(3) <b>chpst</b> is executed with some parameters like <u>-u</u> which executes as user. <b>chpst</b> then executes service with modified state and predefined parameters from <u>./conf</u>. 

This is a foreground service, it means that the executable does not exit til the service is stopped. If the executable exits, you can expect the service to be down.
<b>fiss</b> also includes a stripped-down version of <b>chpst</b> for compability use, <b>fiss</b> includes a basic state management. 

You can extract the chpst-part to <u>./user</u> and <u>./env</u> (see below). 

If you executable has static parameters, thus no <u>./conf</u> and no environment-variables, you can also pass the parameters in <u>./params</u> and sym-link the executable directly to <u>./run</u>. 

Void Linux packages always comes with a symbolic link <u>./supervise</u> to <u>/run/runit/supervise.&lt;service&gt;</u>, which is meant for read-only systems running runit (expecting <u>/run/</u> to be a temporary filesystem). If you are running a writable system, you can remove the link and <b>fiss</b> will create a directory. If you are running a read-only system you can either create the directory <u>/run/runit/</u> and don't have to mess with runit-services or at an other location and sym-link the supervise-directories by yourself. 



If your <u>./run</u> execute looks like the following, stressing the <b>pause</b>... 

+------------------------------------------------------------------------------+
| #!/bin/sh                                                                    |
|                                                                              |
| service -p 990 start                                                         |
| exec chpst -b service pause                                                  |
+------------------------------------------------------------------------------+

... and you <u>./finish</u> like that... 

+------------------------------------------------------------------------------+
| #!/bin/sh                                                                    |
|                                                                              |
| service stop                                                                 |
+------------------------------------------------------------------------------+

... it's a runit-<u>background</u> service which should be converted to a fiss-service. The service executable exits immediately, the actual service is running in the background. 

<b>pause</b> is a runit-hack, a program which just suspends until it is signaled by runit. It blocks a process-slot and the kernel still needs to care about it. <b>fiss</b> handles background-services different by calling <u>./start</u> and <u>./stop</u>. 

You can safely remove the last exec line and rename <u>./run</u> to <u>./start</u> and <u>./finish</u> to <u>./stop</u> and it should work. 

<a class=title id=getting-started href=#getting-started>Getting Started</a>
--------------------------------------------------------------------------------

<b>fiss</b> does not parse any configuration file, everything is configured through different files inside for example /etc/service.d. 

Following files are executed by finit: 

<div class=list>* <u>/usr/share/fiss/start</u>
This is the entry point of your system (similar to <u>/etc/runit/1</u>). By default this script sources files in unix-order inside <u>/etc/start.d/*.sh</u>. </div>
<div class=list>* <u>/etc/service.d/*</u>
In this directory the services are stored, underneath is descripted how a service is constructed. The utility fsvs is written to supervise a service- directory without issuing start and stop mechanisms. </div>
<div class=list>* <u>/usr/share/fiss/stop</u>
This is the ending point of your system-lifetime (similar to <u>/etc/runit/3</u>). By default this script sources file in unix-order inside <u>/etc/stop.d/*.sh</u>. </div>

<b>zzz</b> is a utility shipped with <b>fiss</b> to suspend your system, following files are executed by <b>zzz</b>. <div class=list>* <u>/usr/share/fiss/suspend</u>
This file is executed before suspending, by default this script sources files in unix-order inside <u>/etc/zzz.d/suspend/*.sh</u>. </div>
<div class=list>* <u>/usr/share/fiss/resume</u>
This file is executed after suspending (thus before resuming), by default this script sources files in unix-order inside <u>/etc/zzz.d/resume/*.sh</u>. </div>

<a class=title id=service href=#service>How to create a service?</a>
--------------------------------------------------------------------------------

Services are usually placed into <u>/etc/service.d</u>, a services is a long-running executable like for example sshd, which should be running the whole lifetime of your system. Sadly do some services terminate before your system halts because of an error or signaling, this is where <b>fiss</b> plays its role. 

<div class=list>* <u>./run</u>
Usually your service runs in the foreground, in this case you can create a run executable, either linked to the actual binary or as a script that executes the service. run is meant to be running the whole time in the foreground and must not daemonize itself into the background as <b>fiss</b> would restart it. +----------------------------------------------------------------------------+
| #!/bin/sh                                                                  |
|                                                                            |
| [ -r ./conf ] && . ./conf                                                  |
|                                                                            |
| exec myservice $ARGS                                                       |
+----------------------------------------------------------------------------+This example sources conf in the service-directory if present and executes myservice with <u>$ARGS</u>. </div>
<div class=list>* <u>./params</u>
run often needs parameters, these can be defined inside params. Your arguments must be newline-demilitered. Usually the 0th argument is not included and defaults to './run', but if you want to define the 0th argument you can prefix the first line with '%' and the argument counting starts at 0. No shell-substitution will be done. +----------------------------------------------------------------------------+
| %fiss-service                                                              |
| -L                                                                         |
| -p 8000                                                                    |
+----------------------------------------------------------------------------+In this example, run would be executed with 'fiss-service' as 0th argument and '-L' '-p 8000' </div>
<div class=list>* <u>./env</u>
This file describes environment-variables for run. This is as params a newline-demilitered file with key=value pairs. As for params, there is no shell-substitution done. +----------------------------------------------------------------------------+
| HOME=/home/foo                                                             |
| XDG_CONFIG_DIRS=/etc/                                                      |
| PATH=/bin:/sbin:/usr/bin:/usr/sbin                                         |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./user</u>
If this file is present, run will be executes as defined user and group(s). You can define your user as 'user' and the group will be the user group or you explicitly define 'user:group'. You can add multiple groups with 'user:group:group2:group3', if user is prefixed with a colon (':'), users and groups will be parsed as numeric thus ':1000:1000:1001'. +----------------------------------------------------------------------------+
| foo:foo:mysql                                                              |
+----------------------------------------------------------------------------+In this example, run would be executed as 'foo' and als 'foo' as group with 'mysql' as additional group. </div>
<div class=list>* <u>./start</u>
If your services cannot be run in the foreground, you should execute link it to start, start is a short-running executable, if start exits it is considered as running. To supervise your services, it's handy to provide a pid-file inside your service as some services provide print its process-id to the console. If no pid-file is found you must implement a stop file. +----------------------------------------------------------------------------+
| #!/bin/sh                                                                  |
|                                                                            |
| myserver --print-pid > ./pid                                               |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./pid</u>
This is a plain-text file containing just the PID of the service in decimal. </div>
<div class=list>* <u>./stop</u>
This script is meant to stop the service, if this file exits the service is considered inactive. This file must not coexist with pid. +----------------------------------------------------------------------------+
| #!/bin/sh                                                                  |
|                                                                            |
| myserver2 --stop                                                           |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./depends</u>
This file contains newline-demilitered service-names which are dependencies of the service. dependencies are started before the service will be started and stopped if no enabled and no other service depend on it. Dependencies are just started, no consideration will be done that the dependency is actually active. </div>
<div class=list>* +----------------------------------------------------------------------------+
| dbus                                                                       |
| networking                                                                 |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./setup</u>
If this file is present and executable, it will be executed before run or start, it is meant for example to create files or directories. +----------------------------------------------------------------------------+
| #!/bin/sh                                                                  |
|                                                                            |
| mkdir /var/myserver                                                        |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./finish</u>
If this file is present and executable, it will be executed after run has exited or after stop was executed. This is meant to remove unnessasary files or directories. </div>
<div class=list>* +----------------------------------------------------------------------------+
| #!/bin/sh                                                                  |
|                                                                            |
| rm -rf /var/myserver                                                       |
+----------------------------------------------------------------------------+</div>
<div class=list>* <u>./log</u>
If this file is present, <b>fiss</b> will write the stdout and stderr of run to it. This will be done without any modifications. </div>
<div class=list>* <u>./log/</u> service
If this directory is present and a valid service-directory, stdout and stderr of your service will be redirected to the run of the log-service. This is done with a internal pipe, thus no data will be lost of either services failes. </div>
<div class=list>* <u>./no-log</u>
If this file is present, no logging will be done at all. This is meant for very verbose services, which would overflout the system.
If <u>log</u>, <u>log/</u> or <u>no-log</u> is not present, the output of will be redirected to /run/fiss/log/&lt;service&gt;. </div>
<div class=list>* <u>./up-&lt;runlevel&gt;</u>
If this file is present, the services will be started automatically and restarted if this services dies. On other systems, this is called 'enabling' a service. </div>
<div class=list>* <u>./once-&lt;runlevel&gt;</u>
If this file is present, the services will be started automatically but not restarted if this services dies. </div>

To be a valid service, <u>run</u>, <u>start</u> or <u>depends</u> must be present. If only depends is present, this service is a dummy service thus no actual action will be taken but starting and stopping dependencies. 

<u>start</u>, <u>stop</u>, <u>setup</u> and <u>finish</u> are executed as the same user as <b>fsvs</b> or <b>finit</b> is started, thus root in the most cased. <u>user</u>, <u>env</u>, <u>params</u> are not read when handling a background-service. Every file will be executed in the services directory, reading a file like './conf' will be read out of the service directory. 
</div>
</body>
</html>

