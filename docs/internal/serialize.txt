FISS CONTROL RESPONSE
=====================

+--+-/ /-+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|   NAME0   |    PID    |     STATUS CHANGE     |FC|RC|FLAGS|
+--+-/ /-+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
NAME0 = name of services | null-terminated
PID = pid of the current instance (dependening on state) | big endian
STATUS CHANGE = unix timestamp of last update (why tai tho?) | big endian
FC = fail count
RC = last return code (0 if not exitted yet)

FLAGS
-----

+--+--+--+--+--+--+--+--*--+--+--+--+--+--+--+--+
|   STATE   |RSFIL|RSMAN|LSTEX|RD|PS|LS|HL| --- |
+--+--+--+--+--+--+--+--*--+--+--+--+--+--+--+--+
RSFIL = restart file (up-<runlevel>; 0 = down, 2 = once, 3 = restart)
RSMAN = restart manual override (0 = down, 1 = force down, 2 = once, 3 = restart)
RD = absolute restart needed, combining above + dependencies
LSTEX = last exit (0 = never exitted, 1 = normally, 2 = signaled)
PS = paused
LS = is log service
HS = has log service (in struct is pointer but stored as (void*) 1 or (void*) 0)
-- = nothing yet


RUNIT CONTROL RESPONSE
======================

+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|      TAI SECONDS      | TAIA NANO |    PID    |PS|WU|TR|ST|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
TAI SECONDS = unix seconds + 4611686018427387914ULL | lower endian!
TAIA NANO = unix nanoseconds (nulled-out as fiss don't store them)
PID = current pid | big endian
PS = is paused (int boolean)
WU = wants up ('u' if want up, 'd' if want down)
TR = was terminated (int boolean)
ST = state (0 is down, 1 is running, 2 is finishing)

yuup, there are no flags, boolean-flags still use the whole byte (and WU even uses 'u'/'d')